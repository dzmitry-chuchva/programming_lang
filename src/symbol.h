/*! \file          symbol.h
 *  \author        Чучва Дмитрий
 *  \date          07.12.2006
 *  \brief         заголовочный файл с описаниями, используемыми для работы с таблицей символов
 *
 *  Этот файл содержит описания макросов, типов, переменных, функций для работы с таблицей символов
 *  компилятора. Таблица символов - это структура, ассоциирующая идентификаторы переменных с их типами
 *  и другой семантической информацией, извлекаемой в процессе синтаксического и семантического анализа.
 */

#ifndef __SYMBOL_H
#define __SYMBOL_H

//! указатель на 0
#ifndef NULL
#define NULL 0
#endif

//! максимальная длина индентификатора
#define MAX_SYMBOL_NAME	255

//! предопределенный идентификатор типа целое
#define INT_STR		"int"
//! предопределенный идентификатор типа вещественное
#define FLOAT_STR	"float"
//! предопределенный идентификатор функции точки входа в программу аналогично main в С
#define ENTRY_SYMBOL	"entry"

//! строка, которая используется для вывода сообщения об семантической ошибке
/*! \sa static_error
 */
#define ERROR	"error"
//! строка, которая используется для вывода сообщения об семантическом предупреждении
/*! \sa static_error
 */
#define WARN	"warning"

//! префикс идентификаторов строк в таблице символов
#define STRINGRESOURCE	"STR"
//! префикс идентификаторов временных переменных в таблице символов
#define TEMPPREFIX	"TMP"
//! префикс-идентификатор для констант в таблице символов
#define CONSTANTSNAME	"0CONST"
//! префикс идентификаторов меток в таблице символов
#define LABELPREFIX	"LB"


#define TYPE_UNKNOWN	0x0000			   //!< тип символа - неизвестный

#define TYPE_DECLARED	0x0001			  //!< символ объявлен  
#define TYPE_DEFINED	0x0002			   //!< символ определен

#define TYPE_VAR        0x0004			//!< символ является переменной
#define TYPE_PROC       0x0008			//!< символ является функцией
#define TYPE_ARG		0x0010				  //!< символ является аргументом
#define TYPE_CONST		0x0020				//!< символ является константой
#define TYPE_LABEL		0x0040				//!< символ является меткой
#define TYPE_TEMP		0x0080				 //!< символ временный

#define TYPE_INT        0x0100			//!< тип символа целый
#define TYPE_FLOAT      0x0200			//!< тип символа вещественный
#define TYPE_STRING		0x0400			   //!< тип символа строка


//! объединение, служащее для хранения значения (может быть либо вещественным либо целым)
typedef union tag_val {
	float fval;							   //!< вещественное значение
	int ival;							   //!< целое значение
} val_t;

//! стуктура, описывающая символ в таблице символов
/*! 
 *  Центральная структура в компиляторе. Содержит всю информацию о переменных, 
 *  функциях, константах, метках, временных переменных, и т.д.
 */
typedef struct tag_symbol {
        char *name;						//!< строковый идентификатор символа
        int type;						//!< битовая маска типа символа
		struct tag_symbol *table;			  //!< указатель на локальную таблицу символов (для функций), значение типа val_t (для инициализированных переменных), строка типа char* для строк
        struct tag_symbol *next;		//!< следующий символ в таблице символов
		struct tag_symbol *prev;			  //!< предыдущий символ в таблице символов
} symbol;

//! структура, предназначенная для реализации вложенности функций
/*! 
 *  Стуктура предназначена для реализации вложенности функций. На самом деле
 *  возможности ее используются не полностью, так как существуют всего два уровня вложенности:
 *  глобальный и локальный (функция), что следует из спецификации языка. Поэтому вложенные элементы
 *  называются контекстами: локальный  и глобальный.
 */
typedef struct tag_cstack {
		symbol **table;						  //!< таблица символов контекста
		struct tag_cstack *next;			  //!< предыдущий (глобальный) контекст
} context_stack_member;

//! таблица символов глобального контекста
extern symbol *global_table;
//! хвост таблицы символов глобальнон контекста
extern symbol *symtable_end;
//! следующий номер временной переменной
/*! \sa install_temp
 */
extern int next_temp_no;
//! следующий номер метки
/*! \sa install_label
 */
extern int next_label_no;
//! следующий номер строки
/*! \sa install_string
 */
extern int next_string_no;

//! стек контекстов
/*! 
 *  В силу того, что существует всего 2 контекста, максимальное количество элементов стека
 *  равно 2. Но, структура context_stack_member разрабатывалась с учетом того, что количество
 *  контекстов (вложенности процедур) неограничено. Поэтому, вы сможете легко добавить возможности
 *  описания переменных в блоках операторов (как в языке C++), например.
 */
extern context_stack_member *context;

//! устанавливает символ
/*!
 *  Фунцкия устанавливает символ с идентификатором name и типом type в таблицу символов текущего
 *  контекста. Эта функция вызывается лексическим сканером при определении токена, соответствующего
 *  идентификатору. Фукнция определяет таблицу символов текущего контекста и вызывает функцию install_in_table.
 *  \param name идентификатор символа
 *  \param type битовая маска типа символа
 *  \return указатель в таблице символов на созданный символ
 */
symbol *install(char *name, int type);

//! устанавливает символ в заданной таблице символов
/*!
 *  Функция устанавливает символ с идентификатором name и типом type в таблицу символов
 *  table. Эта функция является основой для семейства функций install* .
 *  \param table  таблица символов
 *  \param name   идентификатор символа
 *  \param type   битовая маска типа символа
 *  \return указатель в таблице символов на созданный символ
 */
symbol *install_in_table(symbol **table,char *name,int type);
//! устанавливает временный символ
/*!
 *  Функция устанавливает временный символ с типом type в таблицу символов текущего контекста.
 *  Имя символа формируется автоматически из префикса временного символа TMPPREFIX и номера следующего
 *  временного символа next_temp_no.
 *  \param type битовая маска типа символа
 *  \return указатель в таблице символов на созданный символ
 */
symbol *install_temp(int type);
//! устанавливает символ константы
/*!
 *  Функция устанавливает символ константы с типом type в таблицу символов глобального контекста.
 *  Имя символа для всех констант одинаковое и определяется макроопределением CONSTANTNAME.
 *  \param type битовая маска типа символа
 *  \param val  значение константы
 *  \return указатель в таблице символов на созданный символ
 */
symbol *install_const(int type,val_t val);
//! устанавливает метку в таблицу символов
/*!
 *  Функция устанавливает символ метки в таблицу символов глобального контекста.
 *  Имя символа формируется автоматически из префикса метки LABELPREFIX и номера следующей
 *  метки next_label_no.
 *  \return указатель в таблице символов на созданный символ
 */
symbol *install_label();
//! устанавливает символ строки
/*!
 *  Функция устанавливает символ строки в таблицу символов глобального контекста.
 *  Имя символа формируется автоматически из префикса строки STRINGRESOURCE и номера следующей
 *  строки next_string_no.
 *  \param str строка для установки
 *  \return указатель в таблице символов на созданный символ
 */
symbol *install_string(char *str);
//! ищет символ в таблице символов текущего контекста с заданным идентификатором
/*!
 *  Функция производит поиск символа в таблице символов текущего контекста и возвращает указатель
 *  на него в случае успеха. Используется в лексическом сканере для определения необходимости
 *  установки нового символа либо использовании уже имеющегося. Если символ не найден в текущем
 *  контексте, производится поиск символа с таким именем в глобальном контексте. Если не найдено
 *  и в глобальном контексте, то возращает NULL.
 *  \param name идентификатор для поиска
 *  \return указатель в таблице символов на найденный символ, либо NULL, если символ не найден
 */
symbol *lookup(char *name);
//! ищет символ в заданной таблице символов с заданным идентификатором
/*!
 *  Функция производит поиск символа с заданным идентификатором в заданной таблице символов и возвращает
 *  указатель на него в случае успеха.
 *  \param table таблица символов, где производится поиск
 *  \param name  идентификатор для поиска
 *  \return указатель в таблице символов на найденный символ, либо NULL, если символ не найден
 */
symbol *lookup_table(symbol *table,char *name);
//! ищет символ в заданной таблице символов с заданным идентификатором и типом
/*!
 *  Функция производит поиск символа с заданным идентификатором и типом в заданной таблице символов и возвращает
 *  указатель на него в случае успеха. Является основой для семейства функций lookup* .
 *  \param table     таблица символов, где производится поиск
 *  \param name      идентификатор для поиска
 *  \param type_mask битовая маска типа символа
 *  \return указатель в таблице символов на найденный символ, либо NULL, если символ не найден
 */
symbol *lookup_table_type(symbol *table,char *name,int type_mask);
//! возвращает номер символа
/*!
 *  Функция возвращает порядковый номер символа (начиная с 0) в заданной таблице символов среди
 *  всех символов с типом, подходящим под маску типа type.
 *  \param symb      таблица символов
 *  \param name      идентификатор символа
 *  \param type_mask битовая маска типа символов
 *  \return номер символа среди всех символов с подходящим под маску типом
 */
int symbol_no(symbol *symb,char *name,int type_mask);
//! ищет аргумент по номеру
/*!
 *  Функция возвращает указатель на символ-аргумент с номером no в заданной таблице символов.
 *  \param symb таблица символов
 *  \param no   порядковый номер
 *  \return указатель на найденный символ, либо NULL, если символа с таким номером не существует
 */
symbol *lookup_arg(symbol *symb, int no);
//! ищет аргумент по имени
/*!
 *  Функция возвращает указатель на символ-аргумент с заданным идентификатором name 
 *  в заданной таблице символов.
 *  \param symb таблица символов
 *  \param name имя аргумента
 *  \return указатель на найденный аргумент, либо NULL, если символа с таким именем не существует
 */
symbol *lookup_arg_by_name(symbol *symb, char *name);
//! возвращает хвост таблицы символов
/*!
 *  Функция возвращает указатель на последний символ в заданной таблице символов.
 *  \param table таблица символов
 *  \return указатель на последний символ в таблице
 */
symbol *tail(symbol *table);
//! удаление символа
/*!
 *  Функция удаляет символ из таблицы символов.
 *  \param symb таблица символов
 */
void delete_symbol(symbol *symb);

//! производит смену контекста
/*!
 *  Функция создает новый контекст и ассоциирует ему заданную таблицу символов. Затем указатель
 *  на новый контекст кладется на вершину стека контекстов.
 *  \param table таблица символов для нового контекста
 */
void change_context(symbol **table);
//! восстанавливает контекст
/*!
 *  Функция восстанавливает предыдущий контекст путем выталкивания из стека контекстов верхнего
 *  элемента. Вызывается при выходе из функции, например.
 */
void restore_context();
//! ищет символ только в текущем контексте
/*!
 *  Функция производит поиск только в заданном контексте, в отличие от lookup.
 *  \param name идентификатор для поиска
 *  \return указатель на найденный символ
 */
symbol *search_context(char *name);
//! получить глобальный контекст
/*!
 *  Функция возвращает указатель на глобальный контекст.
 *  \return указатель на глобальный контекст
 */
context_stack_member *get_global_context();
//! получает таблицу символов текущего контекста
/*!
 *  Функция возращает указатель на таблицу символов текущего контекста.
 *  \return указатель на таблицу символов текущего контекста
 */
symbol *get_current_context_table();
//! уничтожает стек контекстов
/*!
 *  Функция производит удаление стека контекстов из памяти, используется в ходе завершения приложения.
 */
void destroy_context_stack();

//! подсчет количества символов в таблице
/*!
 *  Функция производит вычисление количества символов в заданной таблице символов с заданным типом.
 *  \param symb      таблица символов
 *  \param type_mask маска типа для символов
 *  \return количество символов
 */
int count_symbols(symbol *symb, int type_mask);
//! подсчет количества аргументов в таблице символов
/*!
 *  Функция производит подсчет количества символов-аргументов в заданной таблице символов
 *  \param symb таблица символов
 *  \return количество аргуметов в таблице символов
 */
int count_args(symbol *symb);
//! получает строковое представление типа символа
/*!
 *  Функция получает строковое представление типа символа. Используется при отладке.
 *  \param symb символ
 *  \param str  строка, в которой необходимо сформировать представление
 *  \return указатель на переданную сформированную строку
 */
char *get_typestr(symbol *symb,char *str);


//! удаляет локальные символы
/*!
 *  Функция производит удаление заданного символа из талицы символов текущего контекста.
 *  \param symb символ для удаления
 */
void delete_local(symbol *symb);
//! уничтожает таблицу символов
/*!
 *  Функция производит освобождение памяти, занятой под таблицу символов.
 *  \param *from указатель на таблицу символов
 */
void destroy_symtable(symbol **from);
//! выводит таблицу символов на экран
/*!
 *  Функция производит вывод таблицы символов на экран. Используется при отладке.
 *  \param table таблица символов
 */
void print_symtable(symbol *table);

//! тестирует, является ли символом
/*!
 *  Функция проверяет наличие символа в таблице символов текущего контекста. Аналог search_context.
 *  \param symb символ для проверки
 *  \return 1 - существует, 0 - такого символа нет.
 */
int issymbol(symbol *symb);

//! проверяет, является ли символ определенным
#define IS_DEFINED(s)			(s -> type & TYPE_DEFINED)
//! проверяет, является ли символ объявленным
#define IS_DECLARED(s)			(s -> type & TYPE_DECLARED)

//! проверяет, является ли символ функцией
#define IS_PROC(s)				(s -> type & TYPE_PROC)
//! проверяет, является ли символ переменной
#define IS_VAR(s)				(s -> type & TYPE_VAR)
//! проверяет, является ли символ аргументом
#define IS_ARG(s)				(s -> type & TYPE_ARG)
//! проверяет, является ли символ константой
#define IS_CONST(s)				(s -> type & TYPE_CONST)
//! проверяет, является ли символ меткой
#define IS_LABEL(s)				(s -> type & TYPE_LABEL)
//! проверяет, является ли символ временным символом
#define IS_TEMP(s)				(s -> type & TYPE_TEMP)
//! проверяет, является ли символ строкой
#define IS_STRING(s)			(s -> type & TYPE_STRING)

//! делает переменную объявленной с заданным типом
#define DECLARE_VAR(s,typ)		s -> type = TYPE_DECLARED | TYPE_VAR | typ;
//! делает аргумент объявленной с заданным типом
#define DECLARE_ARG(s,typ)		s -> type = TYPE_DECLARED | TYPE_ARG | typ;
//! делает константу объявленной с заданным типом
#define DECLARE_CONST(s,typ)	s -> type = TYPE_DECLARED | TYPE_ARG | typ;
//! делает метку объявленной
#define DECLARE_LABEL(s)		s -> type = TYPE_DECLARED | TYPE_LABEL;

//! делает функцию объявленной с заданным типом возвращаемого значения
#define DECLARE_PROC(s,typ)		s -> type = TYPE_DECLARED | TYPE_PROC | typ;

//! делает символ определенным
#define DEFINE(s)				s -> type |= TYPE_DEFINED | TYPE_DECLARED;

//! получает тип символа (целый/вещественный)
#define TYPE_OF(s)				(s -> type & (TYPE_FLOAT | TYPE_INT))

#endif
