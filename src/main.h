/*! \file          main.h
 *  \author        Чучва Дмитрий
 *  \date          08.12.2006
 *  \brief         основной заголовочный файл
 *
 * Заголовочный файл главного файла проекта.
 */

#ifndef __MAIN_H
#define __MAIN_H

//! указывает bison на то, чтобы формировались более детальные описания ошибок для функции yyerror
#define YYERROR_VERBOSE 1
//! указывает bison на то, что необходимо встроить поддержку отладки в генерируемый анализатор
#define YYDEBUG 1

#include "symbol.h"
#include "code3.h"
#include "codetable.h"
#include "asm_code.h"
#include "unistack.h"

#include "math.h"
#include "stdio.h"
#include "stdlib.h"
#include "stdarg.h"
#include "string.h"
#include "time.h"

//! указываем на то, что используется ANSI C (после включения стандартных заголовочных файлов!).
/*! 
*  Если этого не сделать, приложение не скомпилируется компилятором Microsoft C++, т.к. bison
*  сделает определение функции yyparse в стиле C, когда типы параметров определяются не в
*  заголовке функции, а сразу следуют за ним. Так как по умолчанию bison генерирует объявление
*  yyparse без параметров (YYPARSE_PARAM не установлено), то определение функции будет выглядеть
*  так:
*        int
*        yyparse()
*            ;
*  Компилятор C++ из состава Visual Studio разберет эти строки как прототип функции,
*  и укажет на ошибку в следующей строке, где будет находится открывающая фигурная скобка:
*        '{' used at file scope (missing function header?)
*  Другим способом достигнуть того же результата является добавление в свойствах проекта
*  дополнительного параметра командной строки компилятора /Za, который автоматически определяет
*  макро __STDC__.
*/
#define __STDC__

//! макрос, возвращающий значение выражения в зависимости от его типа
#define VALUE(e)	(e.type & TYPE_INT ? e.val.ival : (e.type & TYPE_FLOAT ? e.val.fval : 0))

//! имя временного файла, куда генерируется целевой ассемблерный код
#define ASMTMPFILE	"tmpfile.asm"
//! имя временного объектного файла, используемое при трансляции и компоновке
#define OBJTMPFILE	"tmpfile.obj"
//! список библиотек, с которыми компонуется полученная в результате компиляции программа
/*! 
*  Данный список используется при запуске компоновщика и передается ему
*  в качестве параметров через командную строку 
*/
#define LIBS "win32.LIB libc.lib crtdll.lib iolayer.obj floating.obj"

//! путь к инструментам (траслятор, компоновщик) по умолчанию
#define BINDIR	"bin"
//! путь к библиотекам по умолчанию
#define LIBDIR	"lib"

extern int lineno;
extern int curr_type, 
param_count,
param_index;
extern int expr_count;
extern symbol *curr_symbol,
*call_function,
*curr_function,
*temp;
extern char error_flag,
proc_definition,
syn_errflag,
compile_only;

//! объединение, используемое для приведения типов symbol* и val_t
typedef union {
	symbol *ptr;						   //!< указатель на symbol
	val_t val;							   //!< объединение "значение"
} valptr_t;

extern valptr_t valptr;

//! тип стека вызовов функций в качестве параметров другой функции
/*! 
*  Используется для обработки вложенных вызовов типа f1(f2(f3()),f4(f5(),f6())) вследствие
*  специфики синтаксически управляемой трансляции и того, что переменные param_index, param_count
*  и call_function описаны глобально. Т.е. при обработке вложенного вызова теряется информация в 
*  глобальных перемнных о предыдущем вызове, который обрабатывался до этого.
*/
typedef struct tag_fci_t {
	symbol *call_function;				   //!< символ функции, обработка которого была прервана другим вызовом
	int param_index;					   //!< сохраненное значение param_index
	int param_count;					   //!< сохраненное значение param_count
} fci_t;

extern stack_t *fci_stack;

//! реализует вывод форматированных сообщений об ошибках
/*!
*  Реализует вывод сообщений о семантических ошибках, обнаруженных в тексте программы в процессе
*  синтаксически управляемой трансляции.
*  \param tstr   строка, содержащая тип ошибки
*  \param format формат-срока в стиле printf, но с ограниченным набором спецификаторов типа
*/
void static_error(char *tstr, char *format, ... );

//! выводит информацию о параметрах командной строки
/*!
*  Функция выводит информацию о способе запуска компилятора.
*/
void usage();

#endif